// Generated by CoffeeScript 1.9.3
(function() {
  var Reader,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Reader = window.Reader != null ? window.Reader : window.Reader = {};

  Reader.Layout = (function(superClass) {
    extend(Layout, superClass);

    function Layout(settings, spine) {
      this.settings = settings;
      this.spine = spine != null ? spine : {};
      this.render = bind(this.render, this);
      this.updatePageCollection = bind(this.updatePageCollection, this);
      this.prevSectionsExits = bind(this.prevSectionsExits, this);
      this.generateArticle = bind(this.generateArticle, this);
      this.pageQueue = [];
      this.pageCollection = {};
    }

    Layout.prototype.generateArticle = function(idx, pageSpread, position, section) {
      return $('<article/>', {
        'class': 'spread',
        'data-idx': idx,
        'data-page-spread': pageSpread,
        'data-spine-position': position
      }).append($('<section/>', {
        html: section
      }));
    };

    Layout.prototype.appendToDom = function($spread, n, len) {
      var $background, $backgrounds;
      Reader.prototype.log("      Appending spread " + n + " to DOM.");
      $(this.settings.innerContainer).append($spread);
      if (!$('article.backgrounds').length) {
        $backgrounds = $('<article/>', {
          'class': 'backgrounds'
        }).appendTo('body');
      } else {
        $backgrounds = $('article.backgrounds');
      }
      $background = $('<section/>', {
        'class': 'background',
        'data-background-for': n
      });
      $backgrounds.append($background);
      return Reader.prototype.updatenodeCount($spread.find('*').length, n, len);
    };

    Layout.prototype.prevSectionsExits = function(idx) {
      return (function(_this) {
        return function() {
          var i, j, ref;
          for (i = j = 0, ref = idx - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            if (_this.pageCollection[i] === null) {
              Reader.prototype.log("    Can't render @pageCollection[" + idx + "] because @pageCollection[" + i + "] doesn't exist.");
              return false;
            }
          }
          return true;
        };
      })(this)();
    };

    Layout.prototype.updatePageCollection = function(k, len, section, layoutProps) {
      var $spread, index, item, j, kInt, len1, ref, results;
      kInt = ~~k;
      Reader.prototype.log("Attempting to render @pageCollection[" + kInt + "].");
      if (kInt === 0) {
        this.pageCollection[kInt] = true;
        Reader.prototype.log("  Laying out first section.");
        $spread = this.generateArticle(kInt, layoutProps, kInt, section);
        return this.appendToDom($spread, kInt, len);
      } else if (this.prevSectionsExits(kInt)) {
        Reader.prototype.log("  Laying out section " + kInt);
        this.pageCollection[kInt] = true;
        $spread = this.generateArticle(kInt, layoutProps, kInt, section);
        this.appendToDom($spread, kInt, len);
        ref = this.pageQueue;
        results = [];
        for (index = j = 0, len1 = ref.length; j < len1; index = ++j) {
          item = ref[index];
          if (this.pageQueue[index] && this.prevSectionsExits(index)) {
            this.pageCollection[index] = true;
            Reader.prototype.log("    @pageCollection[" + index + "] exists in the queue, laying out section " + index + ".");
            $spread = this.generateArticle(index, item.props, index, item.content);
            this.appendToDom($spread, index, item.content);
            delete this.pageQueue[index];
            results.push(Reader.prototype.log("      Deleting @pageCollection[" + index + "] from queue."));
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else {
        if ($.inArray(kInt, this.pageQueue) < 0 || this.pageQueue[kInt] === 'undefined') {
          Reader.prototype.log("    Adding @pageQueue[" + kInt + "] to queue.");
          return this.pageQueue[kInt] = {
            content: section,
            props: layoutProps
          };
        }
      }
    };

    Layout.prototype.render = function() {
      return $.when(Reader.Http.prototype.get(this.settings.contentUrl, 'xml')).then((function(_this) {
        return function(data) {
          return _this.spine = Reader.Http.prototype.getSpine(data);
        };
      })(this)).then((function(_this) {
        return function(data) {
          var dataKeys, sectionLen;
          dataKeys = Object.keys(data);
          sectionLen = ~~dataKeys.length - 1;
          _this.pageCollection = dataKeys.reduce(function(o, v, i) {
            o[i] = null;
            return o;
          }, {});
          return $.each(data, function(k, v) {
            return Reader.Http.prototype.get(v.href, 'html', function(section) {
              return _this.updatePageCollection(k, sectionLen, section, v.properties);
            });
          });
        };
      })(this));
    };

    return Layout;

  })(Reader);

}).call(this);
